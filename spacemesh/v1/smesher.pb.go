// Code generated by protoc-gen-go. DO NOT EDIT.
// source: spacemesh/v1/smesher.proto

package spacemesh_v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("spacemesh/v1/smesher.proto", fileDescriptor_27681f805f44e48d) }

var fileDescriptor_27681f805f44e48d = []byte{
	// 412 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0x4f, 0x6f, 0xd4, 0x30,
	0x10, 0xc5, 0xd5, 0x4b, 0xd5, 0x0e, 0xa5, 0x87, 0x1c, 0x40, 0x4a, 0xd1, 0xb6, 0x05, 0xae, 0x64,
	0xbb, 0xc0, 0x19, 0x09, 0xb6, 0x2d, 0xaa, 0x04, 0x52, 0xb5, 0x16, 0x27, 0x0e, 0xe0, 0x94, 0x21,
	0x58, 0xda, 0xd8, 0xc6, 0x33, 0x89, 0xb4, 0x57, 0xbe, 0x2c, 0x5f, 0x03, 0xe5, 0x8f, 0xbd, 0x9b,
	0x2c, 0x5e, 0xe8, 0x2d, 0xca, 0x7b, 0xef, 0xf7, 0xc6, 0xf6, 0x40, 0x4a, 0x56, 0xde, 0x61, 0x89,
	0xf4, 0x63, 0x5a, 0xcf, 0xa6, 0xd4, 0x7c, 0xa0, 0xcb, 0xac, 0x33, 0x6c, 0x92, 0xa3, 0xa0, 0x65,
	0xf5, 0x2c, 0x3d, 0x29, 0x8c, 0x29, 0x96, 0x38, 0x6d, 0xb5, 0xbc, 0xfa, 0x3e, 0xc5, 0xd2, 0xf2,
	0xaa, 0xb3, 0xa6, 0x67, 0x7f, 0xc3, 0x7c, 0xe1, 0x95, 0x45, 0xea, 0x1c, 0x2f, 0x7f, 0x1f, 0xc0,
	0xb1, 0xe8, 0xfe, 0x0b, 0x74, 0xb5, 0xba, 0xc3, 0xe4, 0x1a, 0xe0, 0x86, 0xda, 0x7f, 0x4a, 0x17,
	0xc9, 0xa3, 0xac, 0x2b, 0xc8, 0x7c, 0x41, 0x76, 0xd5, 0x14, 0xa4, 0x67, 0xd9, 0xe6, 0x18, 0xd9,
	0x3a, 0xb1, 0x40, 0xb2, 0x46, 0x13, 0x26, 0x1f, 0xe0, 0xa1, 0x60, 0xe9, 0xf8, 0x9f, 0xa8, 0x67,
	0x43, 0xd4, 0x20, 0x14, 0x68, 0x9f, 0xe0, 0x48, 0xb0, 0xb1, 0x01, 0x76, 0x3e, 0x0e, 0xad, 0xb5,
	0x05, 0xfe, 0xac, 0x90, 0x38, 0x7d, 0xba, 0xcb, 0xd2, 0x63, 0x2f, 0xe1, 0xb0, 0x3f, 0xfe, 0xcd,
	0xb7, 0xe8, 0x80, 0xa7, 0x23, 0x90, 0x0f, 0x04, 0xca, 0x3b, 0x38, 0x98, 0x1b, 0xa5, 0x73, 0x49,
	0x18, 0x85, 0x4c, 0x86, 0x10, 0xef, 0x0f, 0x8c, 0x05, 0x3c, 0x10, 0xc8, 0x01, 0x33, 0xba, 0xdf,
	0x0d, 0xc9, 0x1f, 0xef, 0x7c, 0x87, 0xa3, 0x67, 0xbe, 0x81, 0xfd, 0x8f, 0x4a, 0xbf, 0x97, 0x14,
	0x9d, 0xea, 0xc9, 0x10, 0xd2, 0xb9, 0x37, 0x9e, 0xf0, 0x50, 0x20, 0xf7, 0x88, 0xc9, 0x56, 0x9f,
	0x77, 0x77, 0xf3, 0x9c, 0x46, 0xf5, 0x9e, 0x76, 0x0d, 0x70, 0x6b, 0x88, 0x05, 0x4b, 0xae, 0xe8,
	0x7f, 0x17, 0x6b, 0x9d, 0x08, 0x9c, 0xaf, 0xf0, 0xf8, 0x6d, 0x2d, 0xd5, 0x52, 0xe6, 0x4b, 0x9c,
	0x9b, 0xd2, 0x56, 0x8c, 0x57, 0xba, 0x50, 0x1a, 0xe3, 0xd0, 0x17, 0x43, 0x68, 0x24, 0x1e, 0x1a,
	0x3e, 0xc3, 0xf1, 0xdc, 0xa1, 0x64, 0x6c, 0xda, 0x2f, 0x25, 0xcb, 0x64, 0xb4, 0xa3, 0x43, 0xd5,
	0xdf, 0xc0, 0xf3, 0xdd, 0xa6, 0x1e, 0xfe, 0x6b, 0x0f, 0x4e, 0x9a, 0x5d, 0xf4, 0x42, 0x6b, 0x53,
	0x46, 0x0b, 0x24, 0x52, 0x46, 0x27, 0x17, 0xdb, 0x6b, 0x1b, 0xb1, 0xfa, 0xde, 0xd9, 0x3d, 0x12,
	0xfd, 0x10, 0x16, 0x26, 0x63, 0xcb, 0xad, 0x33, 0x85, 0x43, 0x22, 0xc1, 0x0e, 0x65, 0x19, 0xbd,
	0xca, 0xd7, 0xdb, 0xef, 0x13, 0xa7, 0xf8, 0xbe, 0x8b, 0xbd, 0x7c, 0xbf, 0xe5, 0xbc, 0xfa, 0x13,
	0x00, 0x00, 0xff, 0xff, 0xc1, 0xee, 0xd9, 0x33, 0xdb, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SmesherServiceClient is the client API for SmesherService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SmesherServiceClient interface {
	// Returns true iff node is currently smeshing
	IsSmeshing(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsSmeshingResponse, error)
	// Start smeshing. Will return false if post data is incomplete or missing
	StartSmeshing(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*StartSmeshingResponse, error)
	// Stop smeshing and optionally attempt to delete post init file(s)
	// Returns true if request is accepted by node, false if it fails
	StopSmeshing(ctx context.Context, in *StopSmeshingRequest, opts ...grpc.CallOption) (*StopSmeshingResponse, error)
	// Get the current smesher id generated by the node
	SmesherId(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SmesherIdResponse, error)
	// Get the current coinbase
	Coinbase(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CoinbaseResponse, error)
	// Set the coinbase.
	// Returns true if request succeeds, false if it fails.
	SetCoinbase(ctx context.Context, in *SetCoinbaseRequest, opts ...grpc.CallOption) (*SetCoinbaseResponse, error)
	// Get the current min gas for including txs in blocks by this smesher
	MinGas(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MinGasResponse, error)
	// Set a min gas units for including txs in blocks by this smesher
	// Returns true if request succeeds, false if it fails.
	SetMinGas(ctx context.Context, in *SetMinGasRequest, opts ...grpc.CallOption) (*SetMinGasResponse, error)
	// Returns post data status from the node
	PostStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PostStatusResponse, error)
	// Returns a bit field of all available setup compute engines
	AvailableComputeEngines(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AvailableComputeEnginesResponse, error)
	// Starts (or continues) a post init phase. Supports resuming a previously
	// started init session, as well as changing post params (e.g., post data size)
	// after initial setup.
	// Returns true if request is accepted by node, false if it fails
	CreatePostData(ctx context.Context, in *CreatePostDataRequest, opts ...grpc.CallOption) (*CreatePostDataResponse, error)
	// Stop an ongoing post data init phase and optionally attempt to delete
	// the post data file(s)
	// Returns true if request is accepted by node, false if it fails
	StopPostDataCreationSession(ctx context.Context, in *StopPostDataCreationSessionRequest, opts ...grpc.CallOption) (*StopPostDataCreationSessionResponse, error)
	// Returns a stream of updates to post data file(s) during the init phase
	PostDataCreationProgressStream(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (SmesherService_PostDataCreationProgressStreamClient, error)
}

type smesherServiceClient struct {
	cc *grpc.ClientConn
}

func NewSmesherServiceClient(cc *grpc.ClientConn) SmesherServiceClient {
	return &smesherServiceClient{cc}
}

func (c *smesherServiceClient) IsSmeshing(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsSmeshingResponse, error) {
	out := new(IsSmeshingResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/IsSmeshing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) StartSmeshing(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*StartSmeshingResponse, error) {
	out := new(StartSmeshingResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/StartSmeshing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) StopSmeshing(ctx context.Context, in *StopSmeshingRequest, opts ...grpc.CallOption) (*StopSmeshingResponse, error) {
	out := new(StopSmeshingResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/StopSmeshing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) SmesherId(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SmesherIdResponse, error) {
	out := new(SmesherIdResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/SmesherId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) Coinbase(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CoinbaseResponse, error) {
	out := new(CoinbaseResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/Coinbase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) SetCoinbase(ctx context.Context, in *SetCoinbaseRequest, opts ...grpc.CallOption) (*SetCoinbaseResponse, error) {
	out := new(SetCoinbaseResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/SetCoinbase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) MinGas(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MinGasResponse, error) {
	out := new(MinGasResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/MinGas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) SetMinGas(ctx context.Context, in *SetMinGasRequest, opts ...grpc.CallOption) (*SetMinGasResponse, error) {
	out := new(SetMinGasResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/SetMinGas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) PostStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PostStatusResponse, error) {
	out := new(PostStatusResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/PostStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) AvailableComputeEngines(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AvailableComputeEnginesResponse, error) {
	out := new(AvailableComputeEnginesResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/AvailableComputeEngines", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) CreatePostData(ctx context.Context, in *CreatePostDataRequest, opts ...grpc.CallOption) (*CreatePostDataResponse, error) {
	out := new(CreatePostDataResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/CreatePostData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) StopPostDataCreationSession(ctx context.Context, in *StopPostDataCreationSessionRequest, opts ...grpc.CallOption) (*StopPostDataCreationSessionResponse, error) {
	out := new(StopPostDataCreationSessionResponse)
	err := c.cc.Invoke(ctx, "/spacemesh.v1.SmesherService/StopPostDataCreationSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *smesherServiceClient) PostDataCreationProgressStream(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (SmesherService_PostDataCreationProgressStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SmesherService_serviceDesc.Streams[0], "/spacemesh.v1.SmesherService/PostDataCreationProgressStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &smesherServicePostDataCreationProgressStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SmesherService_PostDataCreationProgressStreamClient interface {
	Recv() (*PostDataCreationProgressStreamResponse, error)
	grpc.ClientStream
}

type smesherServicePostDataCreationProgressStreamClient struct {
	grpc.ClientStream
}

func (x *smesherServicePostDataCreationProgressStreamClient) Recv() (*PostDataCreationProgressStreamResponse, error) {
	m := new(PostDataCreationProgressStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SmesherServiceServer is the server API for SmesherService service.
type SmesherServiceServer interface {
	// Returns true iff node is currently smeshing
	IsSmeshing(context.Context, *empty.Empty) (*IsSmeshingResponse, error)
	// Start smeshing. Will return false if post data is incomplete or missing
	StartSmeshing(context.Context, *empty.Empty) (*StartSmeshingResponse, error)
	// Stop smeshing and optionally attempt to delete post init file(s)
	// Returns true if request is accepted by node, false if it fails
	StopSmeshing(context.Context, *StopSmeshingRequest) (*StopSmeshingResponse, error)
	// Get the current smesher id generated by the node
	SmesherId(context.Context, *empty.Empty) (*SmesherIdResponse, error)
	// Get the current coinbase
	Coinbase(context.Context, *empty.Empty) (*CoinbaseResponse, error)
	// Set the coinbase.
	// Returns true if request succeeds, false if it fails.
	SetCoinbase(context.Context, *SetCoinbaseRequest) (*SetCoinbaseResponse, error)
	// Get the current min gas for including txs in blocks by this smesher
	MinGas(context.Context, *empty.Empty) (*MinGasResponse, error)
	// Set a min gas units for including txs in blocks by this smesher
	// Returns true if request succeeds, false if it fails.
	SetMinGas(context.Context, *SetMinGasRequest) (*SetMinGasResponse, error)
	// Returns post data status from the node
	PostStatus(context.Context, *empty.Empty) (*PostStatusResponse, error)
	// Returns a bit field of all available setup compute engines
	AvailableComputeEngines(context.Context, *empty.Empty) (*AvailableComputeEnginesResponse, error)
	// Starts (or continues) a post init phase. Supports resuming a previously
	// started init session, as well as changing post params (e.g., post data size)
	// after initial setup.
	// Returns true if request is accepted by node, false if it fails
	CreatePostData(context.Context, *CreatePostDataRequest) (*CreatePostDataResponse, error)
	// Stop an ongoing post data init phase and optionally attempt to delete
	// the post data file(s)
	// Returns true if request is accepted by node, false if it fails
	StopPostDataCreationSession(context.Context, *StopPostDataCreationSessionRequest) (*StopPostDataCreationSessionResponse, error)
	// Returns a stream of updates to post data file(s) during the init phase
	PostDataCreationProgressStream(*empty.Empty, SmesherService_PostDataCreationProgressStreamServer) error
}

// UnimplementedSmesherServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSmesherServiceServer struct {
}

func (*UnimplementedSmesherServiceServer) IsSmeshing(ctx context.Context, req *empty.Empty) (*IsSmeshingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsSmeshing not implemented")
}
func (*UnimplementedSmesherServiceServer) StartSmeshing(ctx context.Context, req *empty.Empty) (*StartSmeshingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSmeshing not implemented")
}
func (*UnimplementedSmesherServiceServer) StopSmeshing(ctx context.Context, req *StopSmeshingRequest) (*StopSmeshingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopSmeshing not implemented")
}
func (*UnimplementedSmesherServiceServer) SmesherId(ctx context.Context, req *empty.Empty) (*SmesherIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SmesherId not implemented")
}
func (*UnimplementedSmesherServiceServer) Coinbase(ctx context.Context, req *empty.Empty) (*CoinbaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Coinbase not implemented")
}
func (*UnimplementedSmesherServiceServer) SetCoinbase(ctx context.Context, req *SetCoinbaseRequest) (*SetCoinbaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCoinbase not implemented")
}
func (*UnimplementedSmesherServiceServer) MinGas(ctx context.Context, req *empty.Empty) (*MinGasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MinGas not implemented")
}
func (*UnimplementedSmesherServiceServer) SetMinGas(ctx context.Context, req *SetMinGasRequest) (*SetMinGasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinGas not implemented")
}
func (*UnimplementedSmesherServiceServer) PostStatus(ctx context.Context, req *empty.Empty) (*PostStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostStatus not implemented")
}
func (*UnimplementedSmesherServiceServer) AvailableComputeEngines(ctx context.Context, req *empty.Empty) (*AvailableComputeEnginesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableComputeEngines not implemented")
}
func (*UnimplementedSmesherServiceServer) CreatePostData(ctx context.Context, req *CreatePostDataRequest) (*CreatePostDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePostData not implemented")
}
func (*UnimplementedSmesherServiceServer) StopPostDataCreationSession(ctx context.Context, req *StopPostDataCreationSessionRequest) (*StopPostDataCreationSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopPostDataCreationSession not implemented")
}
func (*UnimplementedSmesherServiceServer) PostDataCreationProgressStream(req *empty.Empty, srv SmesherService_PostDataCreationProgressStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method PostDataCreationProgressStream not implemented")
}

func RegisterSmesherServiceServer(s *grpc.Server, srv SmesherServiceServer) {
	s.RegisterService(&_SmesherService_serviceDesc, srv)
}

func _SmesherService_IsSmeshing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).IsSmeshing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/IsSmeshing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).IsSmeshing(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_StartSmeshing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).StartSmeshing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/StartSmeshing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).StartSmeshing(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_StopSmeshing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopSmeshingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).StopSmeshing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/StopSmeshing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).StopSmeshing(ctx, req.(*StopSmeshingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_SmesherId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).SmesherId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/SmesherId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).SmesherId(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_Coinbase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).Coinbase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/Coinbase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).Coinbase(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_SetCoinbase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCoinbaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).SetCoinbase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/SetCoinbase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).SetCoinbase(ctx, req.(*SetCoinbaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_MinGas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).MinGas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/MinGas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).MinGas(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_SetMinGas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMinGasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).SetMinGas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/SetMinGas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).SetMinGas(ctx, req.(*SetMinGasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_PostStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).PostStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/PostStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).PostStatus(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_AvailableComputeEngines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).AvailableComputeEngines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/AvailableComputeEngines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).AvailableComputeEngines(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_CreatePostData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePostDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).CreatePostData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/CreatePostData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).CreatePostData(ctx, req.(*CreatePostDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_StopPostDataCreationSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopPostDataCreationSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SmesherServiceServer).StopPostDataCreationSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spacemesh.v1.SmesherService/StopPostDataCreationSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SmesherServiceServer).StopPostDataCreationSession(ctx, req.(*StopPostDataCreationSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SmesherService_PostDataCreationProgressStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SmesherServiceServer).PostDataCreationProgressStream(m, &smesherServicePostDataCreationProgressStreamServer{stream})
}

type SmesherService_PostDataCreationProgressStreamServer interface {
	Send(*PostDataCreationProgressStreamResponse) error
	grpc.ServerStream
}

type smesherServicePostDataCreationProgressStreamServer struct {
	grpc.ServerStream
}

func (x *smesherServicePostDataCreationProgressStreamServer) Send(m *PostDataCreationProgressStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SmesherService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spacemesh.v1.SmesherService",
	HandlerType: (*SmesherServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsSmeshing",
			Handler:    _SmesherService_IsSmeshing_Handler,
		},
		{
			MethodName: "StartSmeshing",
			Handler:    _SmesherService_StartSmeshing_Handler,
		},
		{
			MethodName: "StopSmeshing",
			Handler:    _SmesherService_StopSmeshing_Handler,
		},
		{
			MethodName: "SmesherId",
			Handler:    _SmesherService_SmesherId_Handler,
		},
		{
			MethodName: "Coinbase",
			Handler:    _SmesherService_Coinbase_Handler,
		},
		{
			MethodName: "SetCoinbase",
			Handler:    _SmesherService_SetCoinbase_Handler,
		},
		{
			MethodName: "MinGas",
			Handler:    _SmesherService_MinGas_Handler,
		},
		{
			MethodName: "SetMinGas",
			Handler:    _SmesherService_SetMinGas_Handler,
		},
		{
			MethodName: "PostStatus",
			Handler:    _SmesherService_PostStatus_Handler,
		},
		{
			MethodName: "AvailableComputeEngines",
			Handler:    _SmesherService_AvailableComputeEngines_Handler,
		},
		{
			MethodName: "CreatePostData",
			Handler:    _SmesherService_CreatePostData_Handler,
		},
		{
			MethodName: "StopPostDataCreationSession",
			Handler:    _SmesherService_StopPostDataCreationSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PostDataCreationProgressStream",
			Handler:       _SmesherService_PostDataCreationProgressStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "spacemesh/v1/smesher.proto",
}
